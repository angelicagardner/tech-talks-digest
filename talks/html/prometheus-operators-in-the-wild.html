<!DOCTYPE html>

<html>

<head>
    <meta charset="utf-8" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <title>Prometheus Operators in the Wild</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="# Prometheus Operators in the Wild" />
    <link href="styles.css" rel="stylesheet" />
</head>

<body>
    <header>
        <h1><a href="index.html">Tech Talks Digest</a></h1>
    </header>
    <main>
        <article>
            <h2>Prometheus Operators in the Wild</h2>
            <p><strong>Year:</strong> 2024</p>
            <p><strong>Labels:</strong>
                
                <span class="label">observability</span>, 
                
                <span class="label">kubernetes</span>, 
                
                <span class="label">prometheus</span>
                
            </p>
            <div class="content">
                <h1>Prometheus Operators in the Wild</h1>

<p><strong>Speaker(s):</strong> Bartłomiej Płotka &amp; Mahmoud Amin</p>

<p><strong>Video URL:</strong> https://www.youtube.com/watch?v=pMlv626cyGU</p>

<p><strong>Summary:</strong> This talk compares two Kubernetes “agent-only” operators for Prometheus metric collection: the community-maintained Prometheus Operator and Google’s Managed Service for Prometheus (GMP) Operator. Both operators hide complex scrape configs behind custom resources, but the Prometheus Operator uses deployment-based sharding and gives you full back-end features (querying, alerting, HA), whereas GMP runs a daemonset per node for a lightweight, stateless collector that’s built into GKE.</p>

<h2>Timestamps</h2>

<ul>
<li><code>00:00</code> - Introduction to the Talk</li>
<li><code>02:45</code> - Prometheus (collection) in k8s, "agent mode"</li>
<li><code>04:30</code> - Do we need Operators?</li>
<li><code>05:50</code> - Reason 1 why a Prometheus Operator makes sense: Scrape config</li>
<li><code>08:45</code> - Reason 2 why a Prometheus Operator makes sense: Scalability</li>
<li><code>10:15</code> - Prometheus Operator</li>
<li><code>12:00</code> - GMP Operator</li>
<li><code>16:30</code> - Demo</li>
<li><code>21:30</code> - TL;DR: Prometheus vs GMP Operator</li>
<li><code>25:15</code> - Questions</li>
</ul>

<h2>Key Takeaways</h2>

<ul>
<li>Prometheus Operator deploys Prometheus as Deployments with sharding, supports full back-end capabilities (querying, alerting, HA), and uses PodMonitor/ServiceMonitor CRDs.</li>
<li>GMP Operator runs Prometheus as a DaemonSet on each node for stateless collection, offers simpler CRDs, and integrates out-of-the-box with GKE (enabled by default when create new GKE cluster).</li>
<li>Both operators simplify scrape configuration, automate target discovery status reporting, and forward metrics via remote-write to Thanos, Cortex or vendor back-ends.</li>
<li>Choose the Prometheus Operator for a full-featured self-managed stack; choose GMP Operator for a lightweight, managed collection agent in cloud-native environments.</li>
<li>GMP Operator is an agent-only scraper ("collection-focused") which means that it collects metrics and remote-write them to whatever long-term storage or managed Prometheus service you’ve chosen, but it leaves the storage, querying, alerting, and UI entirely to that downstream system.</li>
</ul>

<h3>Questions/Discussion Points</h3>

<ul>
<li>It would be interesting to compare with other operator patterns such as OpenTelemetry Collector (as a Prometheus scraper), Thanos Operator / Cortex Operator (deploy Prometheus instances alongside long-term storage backends) or Cluster Monitoring Operator (the de-facto way in OpenShift) which is built on top of the Prometheus Operator and adds cluster-wide defaults and multi-tenant isolation.</li>
</ul>

            </div>
        </article>
    </main>
</body>

</html>